<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>3D Viewer</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/libktx.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        function assignLightmapOnMaterial(material, lightmap) {
            material.lightmapTexture = lightmap;
            material.lightmapTexture.coordinatesIndex = 1;
            material.useLightmapAsShadowmap = true;
        }
        
        BABYLON.DefaultLoadingScreen.prototype.hideLoadingUI = function(){
          document.getElementById("customLoadingScreenDiv").style.display = "none";
          console.log("scene is now loaded");
        }
        
        var createScene = function () {
            // scene init
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = BABYLON.Color3.Black();
            var camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, 1.6, 7.6, new BABYLON.Vector3(0,1.5,0), scene);
            camera.minZ = 0.01;
            camera.allowUpsideDown = false;
            camera.wheelPrecision = 150;
            camera.attachControl(canvas, true);
            var hdrTexture = new BABYLON.CubeTexture("textures/Studio_Softbox_2Umbrellas_cube_specular.env", scene);
            hdrTexture.gammaSpace = false;
            scene.environmentTexture = hdrTexture;
            var shaderBall, shaderBallGLTFRoot;
        
            // cornell box
            BABYLON.SceneLoader.ImportMesh(
                "",
                "https://models.babylonjs.com/CornellBox/",
                "cornellBox.glb",
                scene,
                function () {
                    // renaming the default gltf "__root__"
                    scene.getMeshByName("bloc.000").parent.name = "__cornell-root__";
                    // material tweaking
                    scene.materials.forEach(function(material){
                        material.environmentIntensity = 1.4;
                    });
                    scene.getMaterialByName("light.000").emissiveColor = BABYLON.Color3.White(); 
                    var monkeyMtl = scene.getMaterialByName("suzanne.000");
                    monkeyMtl.metallic = 0.64;
                    monkeyMtl.roughness = 0.63;
        
                    // we have to cycles through objects to assign their lightmaps
                    let lightmappedMeshes = ["bloc.000", "suzanne.000", "cornellBox.000"];
                    lightmappedMeshes.forEach(function(mesh){
                        let currentMesh = scene.getNodeByName(mesh);
                        let currentMeshChildren = currentMesh.getChildren();
                        // lightmap texture creation
                        let currentLightmap = new BABYLON.Texture(
                            "https://models.babylonjs.com/CornellBox/" + currentMesh.name + ".lightmap.jpg",
                            scene,
                            false,
                            false);
                        switch(currentMesh.getClassName()){
                            case "Mesh":
                                assignLightmapOnMaterial(currentMesh.material, currentLightmap);
                                break;
                            case "TransformNode": 
                                currentMeshChildren.forEach(function(mesh){
                                    assignLightmapOnMaterial(mesh.material, currentLightmap);
                                });
                                break;  
                        }
                    });
        
                    // all new meshes now receive shadows (shadowGenerator created below)
                    scene.meshes.forEach(function(mesh){
                        mesh.receiveShadows = true;
                    });
            });
        
            // BJS logo /*
            BABYLON.SceneLoader.ImportMesh("","https://charlie995.github.io/Model/","QC_attachSteps.glb",scene,(meshes, particleSystems, skeletons, animationGroups) => {
                    // selecting the mesh we will animate later on scene.registerBeforeRender()
                    shaderBall = meshes[0];
                    // renaming the default gltf empty object "__root__" and adapting it to the scene
                    shaderBallGLTFRoot = shaderBall;//.parent;
                    shaderBallGLTFRoot.name = "__shaderBall-root__";
                    shaderBallGLTFRoot.scaling.scaleInPlace(0.1);
                    shaderBallGLTFRoot.position.y = 0.5;
                    shaderBallGLTFRoot.rotationQuaternion = null; //this will help for the rotation anim later
                    
                    // dyn light to generate shadows 
                    var light = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(0, -1, 0), scene);
                    light.position = new BABYLON.Vector3(0, 3, 0);
                    // shadows handling
                    var shadowGenerator = new BABYLON.ShadowGenerator(128, light);
                    shadowGenerator.useBlurExponentialShadowMap = true;
                    meshes.forEach(function(mesh){
                        shadowGenerator.addShadowCaster(mesh);
                    });
                    //animationGroups[3].start(true);
                    //animationGroups[0].stop();
                    //animationGroups[1].start(true);
                    //engine.hideLoadingUI();

                    // UI
                    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    var panel = new BABYLON.GUI.StackPanel();
                    panel.isVertical = false;
                    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                    advancedTexture.addControl(panel);

                    var addButton = function (text, callback) {
                         var button = BABYLON.GUI.Button.CreateSimpleButton("button", text);
                         button.width = "140px";
                         button.height = "40px";
                         button.color = "white";
                         button.background = "green";
                         button.paddingLeft = "10px";
                         button.paddingRight = "10px";
                         button.onPointerUpObservable.add(function () {
                              callback();
                         });
                         panel.addControl(button);
                    }

                    addButton("Play", function () {
                         animationGroups[0].play(true);
                    });

                    addButton("Pause", function () {
                         animationGroups[0].pause();
                    });

                    addButton("Stop", function () {
                         animationGroups[0].reset();
                         animationGroups[0].stop();
                    });

            });
        
            // why not using glow?
            var glowLayer = new BABYLON.GlowLayer("glow", scene, {
                mainTextureFixedSize: 256,
                blurKernelSize: 32
            });
        
            // simple animation for the logo
            /*var time = 0; //this will be used as a time variable
            scene.registerBeforeRender(function() {
                time += 0.1;
                if(shaderBallGLTFRoot != undefined){
                    shaderBallGLTFRoot.rotation.x += 0.002;
                    shaderBallGLTFRoot.rotation.y -= 0.003;
                    shaderBallGLTFRoot.rotation.z -= 0.001;       
                    shaderBallGLTFRoot.position.y = (Math.cos(time*0.1)*0.15) + 1.5;
                }
            });*/

            return scene;
        };
var engine;
try {
    engine = createDefaultEngine();
} catch(e) {
    console.log("the available createEngine function failed. Creating the default engine instead");
    engine = createDefaultEngine();
}
        if (!engine) throw 'engine should not be null.';
        scene = createScene();;
        sceneToRender = scene

        engine.runRenderLoop(function () {
            if (sceneToRender) {
                sceneToRender.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
